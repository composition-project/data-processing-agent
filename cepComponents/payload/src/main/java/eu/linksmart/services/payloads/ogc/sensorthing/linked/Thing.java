
package eu.linksmart.services.payloads.ogc.sensorthing.linked;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import eu.linksmart.services.payloads.ogc.sensorthing.Datastream;
import jdk.nashorn.internal.objects.annotations.Setter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

/**
 * Thing class.
 * <p>
 * <strong>Definition:</strong> We use the ITU-T definition, i.e., with regard
 * to the Internet of Things, a thing is an object of the physical world
 * (physical things) or the information world (virtual things) which is capable
 * of being identified and integrated into communication networks. (ITU-T
 * Y.2060)
 * </p>
 * 
 * @author <a href="mailto:carvajal@fit.fhg.de">Angel Carvajal</a>
 *
 */
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "@iot.id" , scope = Thing.class)
public class Thing extends eu.linksmart.services.payloads.ogc.sensorthing.Thing
{

    /**
	 * The Location entity locates the Thing. Multiple Things MAY be
     * located at the same Location. A Thing MAY not have a
     * Location. A Thing SHOULD have only one Location.
     * However, in some complex use cases, a Thing MAY have more
     * than one Location representations. In such case, the Thing MAY
     * have more than one Locations. These Locations SHALL have
     * different encodingTypes and the encodingTypes SHOULD be in
     * different spaces (e.g., one encodingType in Geometrical space and
     * one encodingType in Topological space).
     **/
    @JsonProperty(value = "historicalLocations")
	@JsonDeserialize(as=ArrayList.class)
    protected List<HistoricalLocation> historicalLocations;
    /**navigationLink is the relative URL that retrieves content of related entities. */

  //  @JsonPropertyDescription("TBD.")
  //  @JsonProperty(value = "HistoricalLocations@iot.navigationLink")
   /* public String getHistoricalLocationsNavigationLink() {
        return "Location("+id+")/HistoricalLocations";
    }*/
   // @JsonPropertyDescription("TBD.")
   // @JsonProperty(value = "HistoricalLocations@iot.navigationLink")
   // public void setHistoricalLocationsNavigationLink(String value) {   }

	@JsonGetter(value = "HistoricalLocations@iot.navigationLink")
	public String getHistoricalLocationsNavigationLink() {
		return "Thing("+id+")/HistoricalLocations";
	}
	@JsonPropertyDescription("TBD.")
	@JsonSetter(value = "HistoricalLocations@iot.navigationLink")
	public void setHistoricalLocationsNavigationLink(String value) {   }

	@JsonGetter(value = "Locations@iot.navigationLink")
	public String getLocationsNavigationLink() {
		return "Thing("+id+")/Locations";
	}
	@JsonPropertyDescription("TBD.")
	@JsonSetter(value = "Locations@iot.navigationLink")
	public void setLocationsNavigationLink(String value) {   }


	@JsonGetter(value = "Datastreams@iot.navigationLink")
	public String getDatastreamsNavigationLink() {
		return "Thing("+id+")/Datastreams";
	}
	@JsonPropertyDescription("TBD.")
	@JsonSetter(value = "Datastreams@iot.navigationLink")
	public void setDatastreamsNavigationLink(String value) {   }



	@JsonIgnore
	protected List<Datastream> datastreams = null;
	/**
	 * Provides the list of datastreams generated by this Thing. The returned
	 * set is Live reference to the internal data structure which is not
	 * Thread-safe. Synchronization and concurrent modification issues might
	 * arise in multi-threaded environments.
	 *
	 * @return the {@link java.util.Set}:{@link eu.almanac.ogc.sensorthing.api.datamodel.Datastream}  of datastreams generated by
	 *         this {@link eu.linksmart.services.payloads.ogc.sensorthing.linked.Thing} instance.
	 */

	@JsonGetter("datastreams")
	public List<Datastream> getDatastreams() {
		return datastreams;
	}
	@JsonSetter("datastreams")
	public void setDatastreams(List<Datastream> datastreams) {
		if(datastreams!=null) {
			datastreams.forEach(d->d.setThing(this));
			this.datastreams = datastreams;
		}

	}
	public void addDatastreams(Datastream datastream) {
		datastream.setThing(this);
		if(!datastreams.contains(datastream))
			datastreams.add(datastream);
	}
	/*

    @JsonPropertyDescription("TBD.")
    @JsonProperty(value = "Locations@iot.navigationLink")
    public String getLocationsNavigationLink() {
        return "Thing("+id+")/Locations";
    }
    @JsonPropertyDescription("TBD.")
    @JsonProperty(value = "Locations@iot.navigationLink")
    public void setLocationsNavigationLink(String value) {}
*/




	/**
	 * Provides the list of locations in which this Thing has been registered.
	 * The returned set is Live reference to the internal data structure which
	 * is not Thread-safe. Synchronization and concurrent modification issues
	 * might arise in multi-threaded environments.
	 *
	 * @return the locations
	 */

	@JsonGetter("historicalLocations")
	public List<HistoricalLocation> getHistoricalLocations() {
		return historicalLocations;
	}


	/**
	 * Sets the list of locations in which this Thing has been registered.
	 * Replaces any existing list.
	 *
	 * @param historicalLocations
	 *            the locations to set
	 */

	@JsonSetter("historicalLocations")
	public void setHistoricalLocations(List<HistoricalLocation> historicalLocations) {
		if(historicalLocations!=null) {
			historicalLocations.forEach(d->d.addThing(this));
			/*
			if I want to add locations in the historical location automatically I have to de-comment this part
			if(locations!= null){
				historicalLocations.forEach(h -> {
					if(h.locations==null)
						h.locations = new ArrayList<>();
					h.setLocations(locations);

				});
			}*/
			this.historicalLocations = historicalLocations;
		}

	}
	public void addHistoricalLocation(HistoricalLocation historicalLocation) {

		if(historicalLocation.things == null)
			historicalLocation.things = new ArrayList<>();

		if(!historicalLocation.things.contains(this))
			historicalLocation.things.add(this);
		if(this.historicalLocations==null)
			this.historicalLocations= new ArrayList<>();
		if(!this.historicalLocations.contains(historicalLocation))
			this.historicalLocations.add(historicalLocation);
	}



	/**
	 * Removes one location from the set of locations in which this
	 * {@link eu.linksmart.services.payloads.ogc.sensorthing.linked.Thing} instance was positioned.
	 *
	 * @param historicalLocations
	 *            The location to remove.
	 * @return true if removal is successful, false otherwise.
	 */
	public boolean removeHistoricalLocations(HistoricalLocation historicalLocations)
	{
		// the removal flag
		boolean removed = false;

		// check if the locations set is not null
		if (this.historicalLocations != null)
			// remove the location
			removed = this.historicalLocations.remove(historicalLocations);

		// return the removal result
		return removed;
	}

///////////////////////////////
protected List<Location> locations;

	@JsonGetter("locations")
	public List<Location> getLocations() {
		return locations;
	}


	/**
	 * Sets the list of locations in which this Thing has been registered.
	 * Replaces any existing list.
	 *
	 * @param locations
	 *            the locations to set
	 */

	@JsonSetter("locations")
	public void setLocations(List<Location> locations) {
		if(locations!=null) {
			locations.forEach(d->d.addThing(this));
			this.locations = locations;
		}

	}
	public void addLocation(Location locations) {
		if(locations.things==null)
			locations.things= new ArrayList<>();
		if(!locations.things.contains(this))
			locations.things.add(this);
		if(this.locations==null)
			this.locations= new ArrayList<>();
		if(!this.locations.contains(locations))
			this.locations.add(locations);
	}

}